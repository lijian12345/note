### 0. 入门

​	以下为一个java应用的简单实例：

- Dockerfile示例：

  ```dockerfile
  FROM openjdk:16-alpine3.13
  
  RUN apk update
  RUN apk add maven
  
  # maven换源
  ADD settings.xml /root/.m2/settings.xml
  
  WORKDIR /app
  
  COPY pom.xml ./
  RUN mvn dependency:go-offline
  
  COPY src ./src
  CMD ["mvn", "spring-boot:run"]
  ```

- 构建命令

  ```
  docker build -t java-docker .
  ```

- 运行命令

  ```
  docker run -dp 8080:8080 java-docker
  ```

  - -d表示以守护态运行，-p表示发布到端口

### 1. 概念

#### 1.1 基本概念

##### 1.1.1 镜像

- 包含软件运行所需的**最小环境**（code, runtime, sysTool, sysLib, config...），本质上是一个特殊的文件系统。
- 镜像构建时是分层构建，**每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。**
  - 比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。

##### 1.1.2 容器

- 镜像运行时的实体。镜像之于容器，就像类之于对象，**可以被创建、启动、停止、删除、暂停等**。
- **容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。**与镜像一样是分层存储。
- **容器存储层的生存周期和容器一样，容器删除，存储层信息则丢失。**因此应该使用数据卷（Volume），或者绑定宿主目录来持久化数据，

##### 1.1.3 仓库

- 存放镜像的地方

#### 1.2 对比虚拟机

- 虚拟机首先虚拟了一套硬件，然后在此之上构建了一个OS，应用运行在这个OS上，使用着虚拟出来的CPU等硬件资源；docker容器本质上就是一个进程，运行在自己的命名空间里，共享着真实CPU等硬件资源。

- 两者定位不同：虚拟机擅长隔离整个运行环境，比如云服务提供商通常采用虚拟机技术隔离不同的用户。**容器通常用于隔离不同的应用** ，例如前端，后端以及数据库。

#### 1.3 底层原理

##### 1.3.0 类比操作系统谈进程隔离

- OS进程存在的问题：
  - OS进程能够相互看到且进行通信，因此高级权限的进程可以攻击其他进程
  - 进程使用的是同一个文件系统，进程可以对已有的数据进行增删改查，其他进程运行就会存在问题；而且进程与进程之间的依赖可能会存在冲突，不方便运维
  - 进程使用的是同一个宿主机的资源，应用之间可能会存在资源抢占的问题，导致其他进程无法正常提供服务
- 针对上述问题进行隔离
  - 使用 namespace 技术来实现进程间的隔离，不同namespace下的进程不可见
  - 使用 chroot 系统调用将子目录变成根目录，使进程具有独立的文件系统。chroot配合namespace可以使进程独立
  - 最后通过 cgroup 来限制进程资源使用率，设置其能够使用的 CPU 以及内存量

##### 1.3.1 LXC(Linux Containers)虚拟化技术

###### 1.3.1.1 cgroup



###### 1.3.1.2 namespace



